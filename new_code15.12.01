#!/usr/bin/env python3
from time import sleep
from ev3dev2.motor import LargeMotor, MediumMotor, OUTPUT_A, OUTPUT_B, OUTPUT_C
from ev3dev2.sensor import INPUT_1, INPUT_2, INPUT_3
from ev3dev2.sensor.lego import TouchSensor, ColorSensor

# --- 1. KONFIGURACJA SPRZĘTU ---

# Silniki
m1 = LargeMotor(OUTPUT_A)  # Lewy motor (OUTPUT_A)
m2 = LargeMotor(OUTPUT_B)  # Prawy motor (OUTPUT_B)
m3 = MediumMotor(OUTPUT_C) # Dodatkowy silnik (nieużywany)

# Sensory
s3 = TouchSensor(INPUT_3)  # Czujnik dotyku (STOP)
s1 = ColorSensor(INPUT_1)  # Lewy sensor (INPUT_1)
s2 = ColorSensor(INPUT_2)  # Prawy sensor (INPUT_2)

# Ustawiamy tryb czujników na odbite światło (0-100)
# Wartości: 0 (Czarny) do 100 (Biały)
s1.mode = 'COL-REFLECT'
s2.mode = 'COL-REFLECT'

# --- 2. PARAMETRY REGULATORA P ---

TP = 30           # (Target Power) Bazowa prędkość (Im większa, tym szybszy robot)
KP = 0.5          # Wzmocnienie Proporcjonalne (Odpowiada za siłę korekty)
THRESHOLD = 30    # Wartość graniczna: Poniżej tej wartości to linia (Czarny)
                  # To jest orientacyjna wartość, którą trzeba dostosować!

# --- 3. GŁÓWNA LOGIKA ---

print("Gotowy. Użyj Touch Sensor (s3), aby rozpocząć.")
s3.wait_for_pressed()
print("Start!")
sleep(0.5) 

sign = 1 # Znak do sterowania kierunkiem / zatrzymaniem

while sign == 1:
    
    # --- A. ODCZYT ---
    l_val = s1.reflected_light_intensity # Odczyt lewego sensora (0-100)
    r_val = s2.reflected_light_intensity # Odczyt prawego sensora (0-100)

    # --- B. OBLICZENIE BŁĘDU ---

    # Błąd: Jeśli robot jest idealnie na linii, jeden sensor widzi czarny (~0), drugi biały (~100).
    # Idealna wartość środka: (Czarne + Białe) / 2.
    # W uproszczonym regulatorze P, błąd jest po prostu różnicą odczytów:
    
    # Przykład:
    #   - L=10 (Czarny) i R=90 (Biały) -> Błąd = 10 - 90 = -80
    #   - L=90 (Biały) i R=10 (Czarny) -> Błąd = 90 - 10 = +80
    
    error = l_val - r_val 
    
    # --- C. OBLICZENIE KOREKTY SKRĘTU ---
    
    turn = error * KP
    
    # --- D. APLIKACJA STEROWANIA ---
    
    # Prędkość dla motorów: bazowa prędkość (TP) + korekta skrętu (turn)
    # 
    #   - Jeśli Błąd jest ujemny (-80) -> turn jest ujemny.
    #     L: TP + (-Turn) = mniejsza prędkość
    #     R: TP - (-Turn) = większa prędkość
    #     Wynik: Lewe koło wolniej, Prawe szybciej => Skręt w Lewo, by złapać linię. PRAWIDŁOWO.
    #
    #   - Jeśli Błąd jest dodatni (+80) -> turn jest dodatni.
    #     L: TP + (+Turn) = większa prędkość
    #     R: TP - (+Turn) = mniejsza prędkość
    #     Wynik: Lewe koło szybciej, Prawe wolniej => Skręt w Prawo, by złapać linię. PRAWIDŁOWO.
    
    speed_m1 = TP + turn
    speed_m2 = TP - turn

    # Ograniczenie mocy do bezpiecznego zakresu (-100 do 100)
    speed_m1 = max(min(speed_m1, 100), -100)
    speed_m2 = max(min(speed_m2, 100), -100)
    
    # Wykonanie ruchu (zakładamy, że TP jest dodatnie, więc jedziemy do przodu)
    m1.on(speed_m1 * sign)
    m2.on(speed_m2 * sign)

    # --- E. ZATRZYMANIE ---
    if s3.is_pressed:
        sign = 0
        m1.off()
        m2.off()
        print("Zatrzymano.")
        break
        
    sleep(0.01) # Krótka przerwa dla stabilności