#!/usr/bin/env python3
from time import sleep
from ev3dev2.motor import LargeMotor, MediumMotor, OUTPUT_A, OUTPUT_B, OUTPUT_C
from ev3dev2.sensor import INPUT_1, INPUT_2, INPUT_3
from ev3dev2.sensor.lego import TouchSensor, ColorSensor

# --- 1. KONFIGURACJA SPRZĘTU ---

# Silniki
m1 = LargeMotor(OUTPUT_A)  # Lewy
m2 = LargeMotor(OUTPUT_B)  # Prawy
m3 = MediumMotor(OUTPUT_C) # Dodatkowy silnik (bezczynny w tym kodzie)

# Sensory
touch_sensor = TouchSensor(INPUT_3) # Czujnik dotyku
s1 = ColorSensor(INPUT_1)           # Lewy sensor (s1)
s2 = ColorSensor(INPUT_2)           # Prawy sensor (s2)

# Ustawiamy tryb czujników na odbite światło (0-100)
s1.mode = 'COL-REFLECT'
s2.mode = 'COL-REFLECT'

# --- 2. PARAMETRY REGULATORA PD I LOGIKI ---

TP = 20           # (Target Power) Bazowa prędkość (Im większa, tym szybszy robot)
KP = 0.5          # Wzmocnienie Proporcjonalne (Odpowiada za siłę korekty)
KD = 1.0          # Wzmocnienie Różniczkujące (Wygładza jazdę na prostych)
THRESHOLD = 30    # Wartość graniczna: poniżej 30 to linia (czarny)

REVERSE_SPEED = -10 # Prędkość cofania (ujemna)
REVERSE_TIME = 0.3  # Czas cofania w sekundach
TURN_TIME = 0.5     # Czas manewru skrętu po cofaniu

# --- 3. ZMIENNE DLA REGULATORA PD ---
last_error = 0 # Przechowujemy poprzedni błąd do obliczenia pochodnej

# --- 4. START PROGRAMU ---

print("Gotowy. Użyj Touch Sensor, aby rozpocząć.")
touch_sensor.wait_for_pressed()
print("Start!")
sleep(0.5) 

running = True
while running:
    
    # --- A. ODCZYT ---
    l_val = s1.reflected_light_intensity
    r_val = s2.reflected_light_intensity

    # --- B. LOGIKA SKRZYŻOWAŃ / DETEKCJA ZAGUBIENIA ---

    # B1. ZAGUBIENIE (Overshoot) - OBA WIDZĄ BIAŁE (znacząco powyżej progu)
    # Wykrycie, że robot całkowicie przejechał linię (koniec skrzyżowania)
    if l_val > THRESHOLD * 2 and r_val > THRESHOLD * 2: 
        
        # Manewr Cofania i Skrętu w Prawo, aby złapać linię
        # 1. Cofanie
        m1.on(REVERSE_SPEED)
        m2.on(REVERSE_SPEED)
        sleep(REVERSE_TIME) 
        
        # 2. Skręt w prawo (Lewe koło do przodu, Prawe stoi/cofnij)
        m1.on(TP)
        m2.off() 
        sleep(TURN_TIME) 

        # Reset błędu i kontynuacja pętli
        last_error = 0
        continue 

    # B2. SKRZYŻOWANIE (OBA CZARNE) - Priorytet jazdy prosto
    # Jeśli oba sensory są na linii, jedź prosto
    if l_val < THRESHOLD and r_val < THRESHOLD:
        m1.on(TP)
        m2.on(TP)
        last_error = 0 # Reset błędu, by regulator nie korygował na skrzyżowaniu
        continue 
        
    # --- C. REGULATOR PD (na proste odcinki i łagodne zakręty) ---

    # C1. Obliczenie Błędu Proporcjonalnego
    error = l_val - r_val # Błąd: Jeśli lewy widzi czarne, błąd jest ujemny, turn będzie ujemny (skręt w lewo)
    
    # C2. Obliczenie pochodnej błędu (Różniczkujący)
    derivative = error - last_error
    
    # C3. Obliczenie Całkowitej Korekty Skrętu
    turn = (error * KP) + (derivative * KD)
    
    # C4. APLIKACJA STEROWANIA
    speed_m1 = TP + turn
    speed_m2 = TP - turn

    # Ograniczenie mocy do bezpiecznego zakresu
    speed_m1 = max(min(speed_m1, 100), -100)
    speed_m2 = max(min(speed_m2, 100), -100)
    
    # Wykonanie ruchu
    m1.on(speed_m1)
    m2.on(speed_m2)
    
    # C5. Zapisanie bieżącego błędu
    last_error = error

    # --- D. ZAKOŃCZENIE ---
    if touch_sensor.is_pressed:
        running = False

# Zatrzymanie wszystkich silników po wyjściu z pętli
m1.off()
m2.off()
m3.off()
